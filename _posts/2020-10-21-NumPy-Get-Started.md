---
title: 认识NumPy
cover: IMG_4354.JPG
header:
    theme: dark
tags: ["NumPy"]
date: 2020-11-14
---
为了完成<机器学习导论>这门课的作业, 我开始了解学习NumPy. 嘛, 至少矩阵乘法什么的已经会了.

NumPy是Python的一个扩展库, 主要用于高阶的数组和矩阵运算, 还提供了很多数组的数学函数.

据说, 在NumPy上针对数组和矩阵的算法, 其运行效率与等效的C语言代码一样快.[^wiki]

还可以结合其他扩展库SciPy, 或Matplotlib使用. 之后可能会用到这两个库吧, 在这里挖个坑.
<!--more-->
[^wiki]: <https://zh.wikipedia.org/wiki/NumPy>


本文内容若无说明, 默认来自于[官方文档](https://www.numpy.org.cn/user/quickstart.html#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)

另外, 注意各函数名的写法: `np.blabla`表示是`numpy`的库函数; `ndarray.blabla`表示是数组的成员函数.

## 基础操作
NumPy的主要对象是多维数组`ndarray`, 里面的元素类型相同 (这一点与Python内置的`list`不同, list可以同时存储不同的类型. 与Python内置的类库`array.array`类似, 但后者只能表示一维数组).

`ndarray`有以下属性;

1. `ndim`: 维度个数. 维度也可成为轴. 维度的个数也可称为`rank`.
2. `shape`: 一个元组, 表示每个维度的大小. 元组的长度就是`ndim`. 其中`(n, )`表示一维数组.
3. `size`: 元素个数.
4. `itemsize`: 单个元素个数

### 创建数组

- `numpy.array(...)`:

- 传Python的列表或元组作参, 不能使用多个参数代表一个元组.
- 可以指定关键字`dtype`类型.
- 当列表和元组是多维时, 创建的数组也是多维的.


- `numpy.zeros(dimensions)`:
  - 传维度元组作参, 创建初始值为0的数组
  - 默认类型是`float64`
- `numpy.ones(dimensions)`:
  - 初始值为1
- `numpy.empty(dimensions)`:
  - 与`zeros`类似, 但初始值是随机的.
- `numpy.range(start, stop, step)`:
  - 与Python的`range`类似, 但返回的是数组.
  - 可以处理浮点值
- `numpy.linspace(start, stop, number)`:
  - 与`numpy.range`类似, 但接收的不是步长, 而是期待的元素个数.

### 切片

与Python的切片操作类似, 可以用`:`来表示范围. 但numpy还支持多个`:`用`...`省略.   
以及, 在提取某一列向量时, 使用`array[:index]`得到的是行向量, 如想得到列向量, 使用`array[:[index]]`. 后者里面的`[index]`, 是利用[高级索引](#高级索引).


## 元素操作

### 算术运算符

**算术运算符**表示对元素操作, 如:`+, -, *, /, ...`.

- 注意: `*` 这里也是对元素操作. 矩阵运算用`@`.
- 支持`+=`, `-=`等, 含义不变, 会改变数组的值.
- 支持关系操作, 得到的是布尔数组
- 对于维数不一样的数组, 会根据广播原则对较小的数组进行扩展. 简单而言就是, 当数组a与数组b操作, 但数组a比数组b缺少一些维度, 而其他维度的大小是相等的. 那么就会对a进行扩展, 把数据duplicate[^broadcast]

[^broadcast]:<https://www.numpy.org.cn/user/basics/broadcasting.html#%E4%B8%80%E8%88%AC%E5%B9%BF%E6%92%AD%E8%A7%84%E5%88%99>



### 一元操作

如求和, 求最大值等. 由`ndarray`类方法来实现. 当作用于数组时, 相当于把数组看成列表, 维度不会体现.  
但也可以在`sum`, `max`函数中指定`axis`关键字, 表示对某个轴的数组分开进行.  
`axis`接受整数的元组, 从高维到低维从0开始编号. 被指定轴x, 就代表着沿该轴折叠塌缩[^axis]

[^axis]:<https://www.sharpsightlabs.com/blog/numpy-axes-explained/>

```py
>>> b = numpy.array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b.sum(axis=0)
array([12, 15, 18, 21])
```

### 通函数

`ufun`, 通用数学函数, 如`sin`, `exp`等. 对**元素**进行运算.

## 数组操作

### 改变形状

- `ndarray.ravel()`: 扁平化
- `ndarray.reshape(...)`: 改变形状, 接受元组作为参数. 若某个维度为`-1`则代表这个维度不定, 根据其他维度和大小计算.
- `ndarray.T`: 转置.

注意: 以上的函数都是返回改变后的数组, 而不改变这个数组本身.
与`reshape(...)`相对应的是`resize(...)`, 后者是会改变数组本身的.

另外, 在处理列向量时, 总是会自动地转成行向量(不知道是什么规则). 因此若想提取列向量, 或得到列向量等, 需要小心. 用`reshape(-1,1)`来设置形状.

### 数组堆叠

`np.column_stack(tuple of column vectors or arrays)`和`row_stack(tuple of raw vectors or arrays)`

其中, 参数是一个元组, 里面是多个数组或向量.

### 排序

numpy提供了三种排序方法, 都是沿着某一个轴进行排序.

"沿着某个轴进行排序"的意思有点像`np.sum`的`axis`参数, `np.sum`会沿着`axis`压缩或折叠, 即沿着该轴(或多个轴)的元素一起求和, 合成一个值. 而这里也是, 沿着该轴(**一个轴**)的元素会形成一个集合,排序发生在这个集合内, 区别在于不会'collapse',  就是说`sum`会把这个集合压缩成一个值, 但排序只是给集合内的元素给一个在这个集合的序. 

另外, 这也表明了, 这种排序不是类似于excel的排序, 即沿着某一列排序, 其他列也跟着排序. 而是把每一列看成一个集合(假设指定`axis = 1`), 每个集合单独排序后, 再组装在一起.

三种排序方法都有`axis`关键字(int, None), 缺省是-1, 表示沿着最后的轴排序. 可能还有`order`关键字, 支持对结构化数组设定排序的第一关键字, 第二关键字, etc.

- `np.sort`: 返回排序后的数组**副本**. 有`order`关键字.
- `np.argsort`: 返回定序后各元素的序/排名. 有`order`关键字.
- `np.lexsort`: 与`np.argsort`类似, 也是返回一个元素的序, 但有很大不同. `lexsort`支持关键字排序, 接收**二维**数组或**一维**数组的元组, 返回的是**一维**的序/排名. 对于二维数组, 其每一列考虑为一个整体进行定序, 每一行各整体的关键字, 从最后一行开始是第一关键字. 对于一维数组的元组, 各数组同一下标的元素构成一个整体, 每个数组是各整体的关键字, 从最后一个数组开始是第一关键字..

#### 关键字排序

我这里的"关键字排序"意思是, 把多个元素看成整体, 以其中几个元素作为关键字, 拿不同整体的关键字比较, 确定整体之间的序.

1. 使用结构化数组 + `sort`, 用`order`关键字.
2. 使用`argsort`, 再提取用哪一个关键字定的序, 再使用高级索引实现用这个序对原数组重排. 缺点在于不支持多关键字.
3. 先从原数组中各整体的关键字提取出来, 各整体的一个关键字构成一个数组, 各整体的多个关键字构成多个数组. 使用`lexsort`对这多个数组定序, 再使用这个序用高级索引对原数组重排.
  
## 数组访问

### 迭代

一个个遍历元素, 可以用`for x in a.flat`, 或者用[迭代器](https://numpy.org/doc/stable/reference/arrays.nditer.html).

一行行遍历, 一列列遍历, 或者一大块一大块遍历, 使用最原始的`for` + 下标访问.
`for x in a`表示沿着`axis = 0`遍历. (这个循环会执行`a.shape[0]`次).


### 高级索引

首先, 与普通索引不同, 高级索引返回的是一个**副本**, 即[深拷贝](#关于拷贝). 可是当出现在赋值的左边时, 依旧表示对原数组进行赋值. 因此, 可以使用高级索引实现花样地给元素分配值.

#### 使用整数数组索引

数组索引实际上就是一次取多个元素, 而且取出的元素是组织好的. 怎么组织这些元素就取决于索引数组的结构了.  
对于数组的下标, 可以给出一个索引数组, 这些索引数组**具有相同的形状**, 这个相同的形状就是到时候取出元素的组织了.

```py
>>> a = np.arange(12).reshape(3,4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> i = np.array( [ [0,1],                        # indices for the first dim of a
...                 [1,2] ] )
>>> j = np.array( [ [2,1],                        # indices for the second dim
...                 [3,3] ] )
>>>
>>> a[i,j]                                     # i and j must have equal shape
array([[ 2,  5],
       [ 7, 11]])
>>>
>>> a[i,2]
array([[ 2,  6],
       [ 6, 10]])
>>>
>>> a[:,j]                                     # i.e., a[ : , j]
array([[[ 2,  1],
        [ 3,  3]],
       [[ 6,  5],
        [ 7,  7]],
       [[10,  9],
        [11, 11]]])
```
这个例子中, 取出的元素成(2, 2)的数组. 数组内的元素源自`a`的哪里, 就取决于`i`, `j`在该位置的取值. 如`i[0, 0] == 0`, `j[0, 0] == 2`, 那么`result[0, 0] == a[0 ,2] ==2`. 索引数组之间也有广播原则.  
当一个下标为一个数字, 则这个下标恒取这个值. 其实就是广播原则.

当高级索引与切分索引结合, 分为两种形式:  
- 当高级索引被切分索引分隔, 形如`x[arr1, :, arr2]`: 则产生的结果与上面类似. 上面例子中的索引数组的形状决定了结果的形状, 而这里也是, 只不过结果的每一个元素都展开成了数组(这个数组的维度就是切分索引那部分维度).
- 当高级索引**都是**相邻的, 形如`x[..., arr1, arr2, :]`: 此时的行为与上面不同. 此时`arr1`与`arr2`的维度(同一个维度)会替代原数组的维度. 如: `x.shape` 是(10，20，30)，`ind` 是（2,3,4）形状的索引数组， 那么 `result = x[..., ind, : ]` 具有形状(10，2，3，4，30). 尤其当索引数组是**一维**时, 效果就是在对那几个维度做切分操作.**(常用)**

由上可得, 当我们想做自定义的切分时, 可以写成`[:,:,arr1,arr1,:,:]`的形式, 其中`arr1`是一维数组, 表示该维度下选择哪几个下标. 但注意的是, 只能对**相邻**维度进行切分. 即不能对立体空间的 x轴 和 z轴 进行切分(假设顺序是 (x, y, z) ).

对数组的高级索引进行赋值时, 若索引数组有重复的值, 那么意味着会有重复赋值的情况. 此时也是合法的, 留下最后一次赋值的结果.

索引数组不一定是`nparray`, 可以写成列表或列表嵌套列表的形式. 实际上合法的形式有很多, 但很复杂, 这里只需记得用`nparray`或列表.

#### 使用布尔数组索引

布尔数组用来索引, 其实就是用布尔数组中的`True`和`False`表示对元素取或不取.

使用布尔数组有两个方法:
1. 使用和待索引数组一样形状的布尔数组: 布尔数组与原数组一一对应. 结果为**一维**数组.
2. 对一个维度使用**一维**布尔数组: 此时就相当于对该维度自定义切分.

### 化为标量

使用`ndarray.item(args)`, args有三种形式:
1. **空**: 当`ndarray`只有一个元素时有效.
2. **整型数**: 将`'ndarray`扁平化后的第几个.
3. **整型元组**: 作为下标. 

## 关于拷贝

### 引用

使用`=`传递, 只是传递对数组的引用.

```py
>>> a = np.arange(12)
>>> b = a            # no new object is created
>>> b is a           # a and b are two names for the same ndarray object
True
>>> b.shape = 3,4    # changes the shape of a
>>> a.shape
(3, 4)
```

### 浅拷贝

创建了不同的对象, 但是数据是**共享**的.

```py
>>> s = a[ : , 1:3]     # spaces added for clarity; could also be written "s = a[:,1:3]"
>>> s[:] = 10           # s[:] is a view of s. Note the difference between s=10 and s[:]=10
>>> a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
```

使用`view`函数返回数组完整的浅拷贝.

### 深拷贝

拷贝整个数据. 使用`copy`函数.

注意: 留意切片的目的, 选择是是否在切片后立即深拷贝!
<!--
## 结构化数组
[^struct]

[^struct]: <https://www.numpy.org.cn/user/basics/rec.html>

结构化数组是元素为结构的数组, 这里的结构是指: 由一些简单数据类型组成. 结构化数组的创建如下:
```py
 x = np.array([('Rex', 9, 81.0), ('Fido', 3, 27.0)],
              dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
```
值得注意的是:
1. 元素一定是元组, 一定要加`dtype`
2. 上面的例子是一个**1维**数组, 而不是**2维**的.
3. 若不加`dypte`, 则是一个普通的数组, 维度是**2维**的.

### dtype -->

## 线性代数

`a @ b`: 矩阵相乘

`a.T`: 矩阵转置

## 具体任务的实现

### 统计个数
[^count]

[^count]: <https://note.nkmk.me/en/python-numpy-count/>




